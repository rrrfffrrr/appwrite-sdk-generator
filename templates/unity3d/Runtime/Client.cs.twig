using Cysharp.Threading.Tasks;
using NativeWebSocket;
using UnityEngine;
using UnityEngine.Networking;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using {{ spec.title | caseUcfirst }}.Extensions;
using {{ spec.title | caseUcfirst }}.Models;

namespace {{ spec.title | caseUcfirst }}
{
    public class Client
    {
        private static readonly int ChunkSize = 5 * 1024 * 1024;

        private string endpoint = "{{spec.endpoint}}";
        private bool useSelfSigned = false;
        
        private readonly Dictionary<string, string> _headers;
        private readonly Dictionary<string, string> _config; // What is the purpose of this field?

        public Client() {
            _headers = new Dictionary<string, string>()
            {
                { "content-type", "application/json" },
                { "origin", $"{{ spec.title | caseLower }}-{Application.platform.ToString().ToLower()}://{Application.identifier}"},
                { "user-agent" , $"{{spec.title | caseUcfirst}}{{ language.name | caseUcfirst }}SDK/{{ sdk.version }} ({Application.platform}; {Application.version})"},
                { "x-sdk-name", "{{ sdk.name }}" },
                { "x-sdk-platform", "{{ sdk.platform }}" },
                { "x-sdk-language", "{{ language.name | caseLower }}" },
                { "x-sdk-version", "{{ sdk.version }}"}{%~ for key,header in spec.global.defaultHeaders %},
                { "{{key}}", "{{header}}" }
                {%~ endfor %}

            };

            _config = new Dictionary<string, string>();
        }

        public Client SetSelfSigned(bool selfSigned)
        {
            useSelfSigned = selfSigned;
            return this;
        }

        public Client SetEndpoint(string endpoint)
        {
            this.endpoint = endpoint;
            return this;
        }

        {%~ for header in spec.global.headers %}
        {%~ if header.description %}
        /// <summary>{{header.description}}</summary>
        {%~ endif %}
        public Client Set{{header.key | caseUcfirst}}(string value) {
            _config.Add("{{ header.key | caseCamel }}", value);
            AddHeader("{{header.name}}", value);

            return this;
        }

        {%~ endfor %}
        public Client AddHeader(string key, string value)
        {
            _headers.Add(key, value);

            return this;
        }

        public UniTask<JObject> Call(EHttpMethods method, string path, Dictionary<string, string> headers, JObject parameters)
        {
            return Call<JObject>(method, path, headers, parameters);
        }

        public async UniTask<TResult> Call<TResult>(EHttpMethods method, string path, Dictionary<string, string> headers, JObject parameters) where TResult : class
        {
            var queryString = method switch {
                EHttpMethods.GET => "?" + parameters.ToQueryString(),
                _ => string.Empty
            };

            if (!Uri.TryCreate(endpoint + path + queryString, UriKind.RelativeOrAbsolute, out var uri))
                uri = new Uri(endpoint + path + queryString);

            var request = new UnityWebRequest(uri, method.ToString());
            if (useSelfSigned)
                request.certificateHandler = new SelfSignedCertificateHandler();

            if ("multipart/form-data".Equals(headers["content-type"], StringComparison.OrdinalIgnoreCase))
            {
                var form = new List<IMultipartFormSection>();

                /* TODO : fill form
                foreach (var parameter in parameters)
                {
                    if (parameter.Key == "file")
                    {
                        form.Add(((MultipartFormDataContent)parameters["file"]).First()!);
                    }
                    else if (parameter.Value is IEnumerable<object> enumerable)
                    {
                        var list = new List<object>(enumerable);
                        for (int index = 0; index < list.Count; index++)
                        {
                            form.Add(new StringContent(list[index].ToString()!), $"{parameter.Key}[{index}]");
                        }
                    }
                    else
                    {
                        form.Add(new StringContent(parameter.Value.ToString()!), parameter.Key);
                    }
                }
                */

                var boundary = UnityWebRequest.GenerateBoundary();
                var formSections = UnityWebRequest.SerializeFormSections(form, boundary);
                request.uploadHandler = new UploadHandlerRaw(formSections)
                {
                    contentType = $"multipart/form-data; boundary=\"{Encoding.UTF8.GetString(boundary)}\""
                };
            }
            else if (method != EHttpMethods.GET)
            {
                string body = JsonConvert.SerializeObject(parameters, Serialization.SerializerSettings);
                request.uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(body));
                headers["content-type"] = "application/json";
            }

            var accepts = new List<string>();
            foreach (var header in _headers)
            {
                request.SetRequestHeader(header.Key, header.Value);
                if (header.Key.Equals("content-type", StringComparison.OrdinalIgnoreCase))
                {
                    if (!accepts.Contains(header.Value))
                        accepts.Add(header.Value);
                }
            }

            foreach (var header in headers)
            {
                request.SetRequestHeader(header.Key, header.Value);
                if (header.Key.Equals("content-type", StringComparison.OrdinalIgnoreCase))
                {
                    if (!accepts.Contains(header.Value))
                        accepts.Add(header.Value);
                }
            }

            await request.SendWebRequest();

            var contentType = request.GetResponseHeader("Content-Type");

            var isJson = contentType.Contains("application/json");
            var isBytes = contentType.Contains("application/octet-stream");
            
            if (request.responseCode >= 400) {
                var message = Encoding.UTF8.GetString(request.downloadHandler.data);

                if (isJson) {
                    if (JsonConvert.DeserializeObject<JObject>(message, Serialization.DeserializerSettings).TryGetValue("message", out var value))
                        message = value.ToString();
                }

                throw new AppwriteException(message, (int)request.responseCode);
            }

            if (isJson)
            {
                var responseString = Encoding.UTF8.GetString(request.downloadHandler.data);
                return JsonConvert.DeserializeObject<TResult>(responseString, Serialization.DeserializerSettings);
            }
            else if (isBytes)
            {
                return (request.downloadHandler.data) as TResult;
            }
            else
            {
                return default!;
            }
        }

        public async UniTask<TResult> UploadFile<TResult>(
            string path,
            Dictionary<string, string> headers,
            JObject parameters,
            InputFile input,
            string paramName,
            string fileId = null,
            Action<UploadProgress> onProgress = null) where TResult : class
        {
            var size = 0L;
            switch(input.SourceType)
            {
                case "path":
                    var info = new FileInfo(input.Path);
                    input.Data = info.OpenRead();
                    size = info.Length;
                    break;
                case "stream":
                    size = (input.Data as Stream).Length;
                    break;
                case "bytes":
                    size = ((byte[])input.Data).Length;
                    break;
            };

            var offset = 0L;
            var buffer = new byte[Math.Min(size, ChunkSize)];

            if (size < ChunkSize)
            {
                switch(input.SourceType)
                {
                    case "path":
                    case "stream":
                        await (input.Data as Stream).ReadAsync(buffer, 0, (int)size);
                        break;
                    case "bytes":
                        buffer = (byte[])input.Data;
                        break;
                }

                var content = new MultipartFormDataContent {
                    { new ByteArrayContent(buffer), paramName, input.Filename }
                };

                parameters[paramName] = content;

                return await Call<TResult>("POST", path, headers, parameters);
            }

            if (!string.IsNullOrEmpty(fileId) && fileId != "unique()")
            {
                // Make a request to check if a file already exists
                var current = await Call<JObject>("GET", $"{path}/{fileId}", headers, new JObject());
                var chunksUploaded = (long)current["chunksUploaded"];
                offset = Math.Min(chunksUploaded * ChunkSize, size);
            }

            TResult result = default;
            while (offset < size)
            {
                switch(input.SourceType)
                {
                    case "path":
                    case "stream":
                        var stream = input.Data as Stream;
                        stream.Seek(offset, SeekOrigin.Begin);
                        await stream.ReadAsync(buffer, 0, ChunkSize);
                        break;
                    case "bytes":
                        buffer = ((byte[])input.Data)
                            .Skip((int)offset)
                            .Take((int)Math.Min(size - offset, ChunkSize))
                            .ToArray();
                        break;
                }

                var content = new MultipartFormDataContent {
                    { new ByteArrayContent(buffer), paramName, input.Filename }
                };

                parameters[paramName] = content;

                headers["Content-Range"] =
                    $"bytes {offset}-{Math.Min(offset + ChunkSize - 1, size)}/{size}";

                result = await Call<TResult>(
                    method: "POST",
                    path,
                    headers,
                    parameters
                );

                offset += ChunkSize;

                var id = result.ContainsKey("$id")
                    ? result["$id"]?.ToString() ?? string.Empty
                    : string.Empty;
                var chunksTotal = result.ContainsKey("chunksTotal")
                    ? (long)result["chunksTotal"]
                    : 0;
                var chunksUploaded = result.ContainsKey("chunksUploaded")
                    ? (long)result["chunksUploaded"]
                    : 0;

                headers["x-appwrite-id"] = id;

                onProgress?.Invoke(
                    new UploadProgress(
                        id: id,
                        progress: Math.Min(offset, size) / size * 100,
                        sizeUploaded: Math.Min(offset, size),
                        chunksTotal: chunksTotal,
                        chunksUploaded: chunksUploaded));
            }

            return result;
        }
    }
}
